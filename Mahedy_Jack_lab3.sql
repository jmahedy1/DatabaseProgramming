/*
Jack Mahedy
CNIT 372 Lab section 007
Estimated Time Spent: 5hrs
Late Hours Used: 0
*/

--Question #1

BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello World');
END;

/* Q1 Query Results

Script output:
PL/SQL procedure successfully completed.

DBMS output:
Hello World
*/


--Question #2

SET SERVEROUTPUT ON;


--Question #3

BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello World');
END;

/* Q3 Query Results

Script output:
Hello World
PL/SQL procedure successfully completed.

DBMS output:
Hello World

After closing SQL Developer
Script output:
PL/SQL procedure successfully completed.

DBMS output:
Hello World

SQL developer does not remember the server output preference.
*/


--Question #4
/*
"The SERVEROUTPUT setting controls whether SQL*Plus prints the output generated by the DBMS_OUTPUT package from PL/SQL procedures." 
Source: Oracle SQL*Plus: The Definitive Guide, 2nd Edition by Jonathan Gennick
Source link: https://www.oreilly.com/library/view/oracle-sqlplus-the/0596007469/re85.html
*/


--Question #5

BEGIN
    dbms_output.put_line('The Ubiquitous Hello World');
END;

/* Q5 Query Results

The Ubiquitous Hello World
*/


--Question #6

BEGIN
    dbms_output.put('The');
    dbms_output.put(' ');
    dbms_output.put('Ubiquitous');
    dbms_output.put(' ');
    dbms_output.put('Hello');
    dbms_output.put(' ');
    dbms_output.put_line('World');
END;

/* Q6 Query Results

The Ubiquitous Hello World
*/


--Question #7
/*
dbms_output.put prints to the current line. dbms_output.put_line prints to the next line.
*/


--Question #8
/*
"This procedure places a partial line in the buffer."
Source: oracle
Source Link: https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/d_output.htm#TTPLP71215
*/


--Question #9
/*
"This procedure places a line in the buffer."
Source: oracle
Source link: https://docs.oracle.com/cd/E11882_01/timesten.112/e21645/d_output.htm#TTPLP71215
*/


--Question #10
/*
.put places a partial line in the buffer. (prints to current line)
.put_line places a whole line in the buffer. (prints to new line)
*/


--Question #11

BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
END;

/* Q11 Query Results

A window pops up asking me for a value. When I do not enter anything and click ok, I get: My name is
When I enter jack, I get: My name is jack
*/


--Question #12

SET VERIFY ON;


--Question #13

BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
END;

/* Q13 Query Results

Script Output:
old:BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
END;
new:BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || 'jack');
END;
My name is jack

PL/SQL procedure successfully completed.

DBMS Output:
My name is jack
*/


--Question #14

SET VERIFY OFF;


--Question #15

BEGIN
    DBMS_OUTPUT.PUT_LINE('My name is ' || '&sv_YourName');
END;

/* Q15 Query Results

Script output:
My name is jack

PL/SQL procedure successfully completed.

DBMS output:
My name is jack
*/


--Question #16
/* 
"The VERIFY setting controls whether or not SQL*Plus displays before and after images of each line that contains a substitution variable."
Source: Oracle SQL*Plus: The Definitive Guide, 2nd Edition by Jonathan Gennick
Source link: https://www.oreilly.com/library/view/oracle-sqlplus-the/0596007469/re106.html
*/


--Question #17

BEGIN
    dbms_output.put_line('My name is ' || '&sv_YourName');
END;

/* Q17 Query Results

My name is jack

I was prompted 1 time. This implies that inputted values persist until they are ran again.
*/


--Question #18

BEGIN
    dbms_output.put_line('Today is ' || '&sv_day');
    dbms_output.put_line('Tomorrow is ' || '&sv_day');
END;

/* Q18 Query Results

You can use the same variable name twice within the same unnamed block. When I executed the code, 
I was asked for sv_day twice, back to back. I put different values for each window and was given 
the correct value.
*/


--Question #19

BEGIN
    dbms_output.put_line('Today is ' || '&&sv_day');
    dbms_output.put_line('Tomorrow is ' || '&sv_day');
END;

/* Q19 Query Results

Today is tues
Tomorrow is tues

I was not prompted for a value when the second DBMS_OUTPUT was executed. I was only prompted for one value 
and it was set for both sv_days.
*/


--Question #20

BEGIN
    dbms_output.put_line('Today is ' || '&&sv_day');
    dbms_output.put_line('Tomorrow is ' || '&sv_day');
END;

/* Q20 Query Results

Today is tues
Tomorrow is tues

I was not prompted for the variable. This implies that variables will persist using the && command.
*/


--Question #21

DECLARE
    v_day varchar(20) := '&sv_day1';
BEGIN
    dbms_output.put_line('Today is ' || v_day);
END;

/* Q21 Query Results

Today is tues
*/


--Question #22

DECLARE
    v_day varchar2(10);

BEGIN
    v_day := to_char(sysdate, 'Day');
    
    dbms_output.put_line('Today is ' || v_day);
    dbms_output.put_line('Tomorrow is ' || to_char(sysdate + 1, 'Day'));
    
END;

/* Q22 Query Results

Today is Tuesday  
Tomorrow is Wednesday
*/


--Question #23

SELECT employeeid
FROM employee
WHERE employeeid = '100001';

/* Q23 Query Results

It returned 1 row

EMPLOYEEID
----------
100001
*/


--Question #24

DECLARE
    v_employeeid employee.employeeid%TYPE;
    v_lastname employee.lastname%TYPE;
    v_firstname employee.firstname%TYPE;

BEGIN
    SELECT employeeid, lastname, firstname
    INTO v_employeeid, v_lastname, v_firstname
    FROM employee
    WHERE employeeid = '100001';
    
    dbms_output.put_line('Employee ID       Lastname        Firstname');
    dbms_output.put_line('===========================================');
    dbms_output.put(v_employeeid);
    dbms_output.put('          ');
    dbms_output.put(v_lastname);
    dbms_output.put('        ');
    dbms_output.put_line(v_firstname);

END;

/* Q24 Query Results

Employee ID       Lastname        Firstname
===========================================
100001          Manaugh        Jim
*/


--Question #25

SELECT employeeid
FROM employee;

/* Q25 Query Results

It returned 40 rows
*/


--Question #26

DECLARE
    v_employeeid employee.employeeid%TYPE;
    v_lastname employee.lastname%TYPE;
    v_firstname employee.firstname%TYPE;

BEGIN
    SELECT employeeid, lastname, firstname
    INTO v_employeeid, v_lastname, v_firstname
    FROM employee;
    
    bdms_output.put_line('Employee ID   Lastname    Firstname');
    bdms_output.put_line('===================================');
    bdms_output.put(v_employeeid);
    bdms_output.put('           ');
    bdms_output.put(v_lastname);
    bdms_output.put('           ');
    bdms_output.put_line(v_firstname);

END;

/* Q26 Query Results

Error starting at line : 407 in command -
DECLARE
    v_employeeid employee.employeeid%TYPE;
    v_lastname employee.lastname%TYPE;
    v_firstname employee.firstname%TYPE;

BEGIN
    SELECT employeeid, lastname, firstname
    INTO v_employeeid, v_lastname, v_firstname
    FROM employee;

    bdms_output.put_line('Employee ID   Lastname    Firstname');
    bdms_output.put_line('===================================');
    bdms_output.put(v_employeeid);
    bdms_output.put('           ');
    bdms_output.put(v_lastname);
    bdms_output.put('           ');
    bdms_output.put_line(v_firstname);

END;
Error report -
ORA-06550: line 11, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT_LINE' must be declared
ORA-06550: line 11, column 5:
PL/SQL: Statement ignored
ORA-06550: line 12, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT_LINE' must be declared
ORA-06550: line 12, column 5:
PL/SQL: Statement ignored
ORA-06550: line 13, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT' must be declared
ORA-06550: line 13, column 5:
PL/SQL: Statement ignored
ORA-06550: line 14, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT' must be declared
ORA-06550: line 14, column 5:
PL/SQL: Statement ignored
ORA-06550: line 15, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT' must be declared
ORA-06550: line 15, column 5:
PL/SQL: Statement ignored
ORA-06550: line 16, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT' must be declared
ORA-06550: line 16, column 5:
PL/SQL: Statement ignored
ORA-06550: line 17, column 5:
PLS-00201: identifier 'BDMS_OUTPUT.PUT_LINE' must be declared
ORA-06550: line 17, column 5:
PL/SQL: Statement ignored
06550. 00000 -  "line %s, column %s:\n%s"
*Cause:    Usually a PL/SQL compilation error.
*Action:
*/


--Question #27
/*
I am attempting to assign 40 values to each of the 3 variables that are type scalar. We can not succesfully do this 
with scalar type variables. It throws an exception. We can do this with a variable that is type composite,
since it can hold multiple variables (like an array).
*/


--Question #28
/*
Scalar type variables can only hold one variable at a time. 
*/


--Question #29

DECLARE
    v_employee employee%rowtype;

BEGIN
    SELECT *
    INTO v_employee
    FROM employee
    WHERE employeeid = '100001';
    
    dbms_output.put_line('Employee ID       Lastname        Firstname');
    dbms_output.put_line('===========================================');
    dbms_output.put_line(v_employee.employeeid||'       '||v_employee.lastname||'       '||v_employee.firstname);

END;

/* Q29 Query Results

Employee ID       Lastname        Firstname
===========================================
100001       Manaugh       Jim

In Q24 we declared specific rows from the table and then selected each row. Since we are using all of the rows, 
Q29 is more efficient. We can just get the entire row of the table in the declare and then in the select, select all (*).
*/


--Question #30
/*
v_customer INTEGER;
*/


--Question #31a

DECLARE
    v_customer INTEGER;
    
BEGIN
    SELECT MAX(COUNT(customerid))
    INTO v_customer
    FROM customer
    GROUP BY SUBSTR(phone, 1, 3);
END;


--Question #31b

DECLARE
    v_customer INTEGER;
    
BEGIN
    SELECT MAX(COUNT(customerid))
    INTO v_customer
    FROM customer
    GROUP BY SUBSTR(phone, 1, 3);

    dbms_output.put_line('Largest # Of Customers');
    dbms_output.put_line(v_customer);
END;

/* Q31b Query Results

Largest # Of Customers
8
*/